# js-doc

## Методы примитивов
## Number()
Объект Number является объектом-обёрткой, позволяющей вам работать с числовыми значениями. Объект Number создаётся через конструктор Number().
```js
let num = Number("123"); // превращает строку в число

new Number(value);
var a = new Number('123'); // a === 123 is false
var b = Number('123'); // b === 123 is true
a instanceof Number; // is true
b instanceof Number; // is false

Number("123"); // 123
Number(""); // 0
Number("0x11"); // 17
Number("0b11"); // 3
Number("0o11"); // 9
Number("foo"); // NaN
Number("100a"); // NaN
```

## toString()
Метод toString() возвращает строковое представление указанного объекта Number.
```js
var count = 10;

console.log(count.toString()); // Выведет '10'
console.log((17).toString()); // Выведет '17'

var x = 6;

console.log(x.toString(2)); // Выведет '110'
console.log((254).toString(16)); // Выведет 'fe'

console.log((-10).toString(2)); // Выведет '-1010'
console.log((-0xff).toString(2)); // Выведет '-11111111'
```


###  Math.max
возвращает наибольшее число из списка
```js
alert( Math.max(3, 5, 1) ); // 5

```
```js
let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN
```

```js
let arr = [3, 5, 1];
alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
```



## String

### splice

### split
Метод split() разбивает объект String на массив строк путём разделения строки указанной подстрокой.
```js
let str = "тест";
alert( str.split('') ); // т,е,с,т
```

### slice
Метод slice() извлекает часть строки и возвращает новую строку без изменения оригинальной строки.

```js
let str1 = "Приближается утро.";
let str2 = str1.slice(1, 8);
console.log(str2); // ВЫВОД: риближа
let str3 = str1.slice(4, -2);
console.log(str3); // ВЫВОД: лижается утр
let str4 = str1.slice(12);
console.log(str4); // ВЫВОД:  утро.
let str5 = str1.slice(30);
console.log(str5); // ВЫВОД: ""
```

### concat

### includes()
Метод includes() проверяет, содержит ли строка заданную подстроку, и возвращает, соответственно true или false.

```js
let str = "Быть или не быть вот в чём вопрос.";

console.log(str.includes("Быть")); // true
console.log(str.includes("вопрос")); // true
console.log(str.includes("несуществующий")); // false
console.log(str.includes("Быть", 1)); // false
console.log(str.includes("БЫТЬ")); // false
```

### replace()
Метод replace() возвращает новую строку с некоторыми или всеми сопоставлениями с шаблоном, заменёнными на заменитель. Шаблон может быть строкой или регулярным выражением, а заменитель может быть строкой или функцией, вызываемой при каждом сопоставлении.
```js
let re = /яблоки/gi;
let str = "Яблоки круглые и яблоки сочные.";
let newstr = str.replace(re, "апельсины");
console.log(newstr); // апельсины круглые и апельсины сочные.
```
```js

let s1 = 'aabcc';
s1 = s1.replace('a','');
console.log(s1); // abcc
s1 = s1.replace('a','1');
console.log(s1); // 1bcc


```



## Array

### push
добавляет элемент в конец.

### shift
удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
Удаляет из массива первый элемент и возвращает его.
```js
let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удаляем Яблоко и выводим его
alert( fruits ); // Апельсин, Груша
```

### unshift
Добавляет элемент в начало массива
```js
let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша
```


### pop
Удаляет последний элемент из массива и возвращает его
```js
let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин
```

### push
Добавляет элемент в конец массива:
```js
let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша
```

### splice
Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.
### join
```js
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]
```

```js
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```
Здесь видно, что splice возвращает массив из удалённых элементов:

```js
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 2 первых элемента
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
```
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
```js
let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

### slice
```js
arr.slice([start], [end])
```
Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.
```js
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
```

### concat
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
```js
arr.concat(arg1, arg2...)
```
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
Если аргумент argN – массив, то копируются все его элементы. Иначе копируется сам аргумент.
```js
let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

### indexOf/lastIndexOf и includes
У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:

* arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
* arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```
Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.

Если мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно использовать arr.includes.

Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.
```js
let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')
```

### find и findIndex/findLastIndex
Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
Здесь пригодится метод arr.find.
```js
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
```
Функция вызывается по очереди для каждого элемента массива:
* item – очередной элемент.
* index – его индекс.
* array – сам массив.
Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
```js
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
```
У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам элемент. Значение -1 возвращается, если ничего не найдено.
Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.
```js
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"},
  {id: 4, name: "Вася"}
];
// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0
// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3
```

### filter
Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
Если найденных элементов может быть много, можно использовать arr.filter(fn).
Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:
```js
let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
```

```js
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

### map
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
```js
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```

```js
let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6
```

### sort(fn)
Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
```js
let arr = [ 1, 2, 15 ];
// метод сортирует содержимое arr
arr.sort();
alert( arr );  // 1, 15, 2
```
По умолчанию элементы сортируются как строки.

```js
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:
```js
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```
Лучше использовать стрелочные функции
```js
arr.sort( (a, b) => a - b );
```

Используйте localeCompare для строк
Для многих алфавитов лучше использовать метод str.localeCompare, для правильной сортировки букв, таких как Ö.
```js
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)
```

### join
```js
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша
```

### reduce/reduceRight
Методы arr.reduce и arr.reduceRight  используются для вычисления единого значения на основе всего массива.
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
Аргументы:
* accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
* item – очередной элемент массива,
* index – его позиция,
* array – сам массив.
При вызове функции результат её предыдущего вызова передаётся на следующий вызов в качестве первого аргумента.
Так, первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих вызовов функции. По окончании он становится результатом reduce.

Тут мы получим сумму всех элементов массива одной строкой:
```js
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15
```

Мы также можем опустить начальное значение:
```js
let arr = [1, 2, 3, 4, 5];

// убрано начальное значение (нет 0 в конце)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```
Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Eсли массив пуст, то вызов reduce без начального значения выдаст ошибку.
```js
let arr = [];

// Error: Reduce of empty array with no initial value
// если бы существовало начальное значение, reduce вернул бы его для пустого массива.
arr.reduce((sum, current) => sum + current);
```

### Array.isArray
Массивы не образуют отдельный тип данных. Они основаны на объектах.
```js
alert(typeof {}); // object
alert(typeof []); // тоже object
```
…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает true, если value массив, и false, если нет.
```js
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```



## Объекты
Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```

```js
let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Также существует специальный оператор "in" для проверки существования свойства в объекте.
```js
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```

## Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
>* new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
>* set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
>* set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
>* set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
>* set.clear() – удаляет все имеющиеся значения.
>* set.size – возвращает количество элементов в множестве.



